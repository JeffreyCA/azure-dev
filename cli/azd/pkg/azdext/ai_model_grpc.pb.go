// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.1
// source: ai_model.proto

package azdext

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AiModelService_ListModels_FullMethodName                = "/azdext.AiModelService/ListModels"
	AiModelService_ListModelVersions_FullMethodName         = "/azdext.AiModelService/ListModelVersions"
	AiModelService_ListModelSkus_FullMethodName             = "/azdext.AiModelService/ListModelSkus"
	AiModelService_GetModelDeployment_FullMethodName        = "/azdext.AiModelService/GetModelDeployment"
	AiModelService_ResolveModelDeployment_FullMethodName    = "/azdext.AiModelService/ResolveModelDeployment"
	AiModelService_ValidateModelAvailability_FullMethodName = "/azdext.AiModelService/ValidateModelAvailability"
	AiModelService_ListUsages_FullMethodName                = "/azdext.AiModelService/ListUsages"
	AiModelService_ListLocationsWithQuota_FullMethodName    = "/azdext.AiModelService/ListLocationsWithQuota"
	AiModelService_ListSkuLocations_FullMethodName          = "/azdext.AiModelService/ListSkuLocations"
)

// AiModelServiceClient is the client API for AiModelService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AiModelServiceClient interface {
	// ListModels lists AI models, optionally filtered by location, capabilities, format, kind, status.
	// If no location is specified, aggregates across all available locations concurrently.
	ListModels(ctx context.Context, in *ListModelsRequest, opts ...grpc.CallOption) (*ListModelsResponse, error)
	// ListModelVersions gets available versions for a specific model in a location.
	ListModelVersions(ctx context.Context, in *ListModelVersionsRequest, opts ...grpc.CallOption) (*ListModelVersionsResponse, error)
	// ListModelSkus gets available SKUs for a specific model and version in a location.
	ListModelSkus(ctx context.Context, in *ListModelSkusRequest, opts ...grpc.CallOption) (*ListModelSkusResponse, error)
	// GetModelDeployment gets deployment configuration for a model, resolving defaults for version, SKU, and capacity.
	GetModelDeployment(ctx context.Context, in *GetModelDeploymentRequest, opts ...grpc.CallOption) (*GetModelDeploymentResponse, error)
	// ResolveModelDeployment resolves a deployment configuration with quota validation.
	// Attempts to find a deployment that satisfies the specified preferences AND has available quota.
	// Falls back through SKU/location alternatives if the preferred configuration lacks quota.
	ResolveModelDeployment(ctx context.Context, in *ResolveModelDeploymentRequest, opts ...grpc.CallOption) (*ResolveModelDeploymentResponse, error)
	// ValidateModelAvailability checks whether a model can be deployed in a location.
	// Returns availability status and, if unavailable, alternative locations and models.
	ValidateModelAvailability(ctx context.Context, in *ValidateModelAvailabilityRequest, opts ...grpc.CallOption) (*ValidateModelAvailabilityResponse, error)
	// ListUsages gets quota and usage for AI services in a location (TPM allocation, remaining capacity).
	ListUsages(ctx context.Context, in *ListUsagesRequest, opts ...grpc.CallOption) (*ListUsagesResponse, error)
	// ListLocationsWithQuota finds locations that have sufficient quota for specified usage requirements.
	ListLocationsWithQuota(ctx context.Context, in *ListLocationsWithQuotaRequest, opts ...grpc.CallOption) (*ListLocationsWithQuotaResponse, error)
	// ListSkuLocations gets available locations for AI Services resource SKUs.
	ListSkuLocations(ctx context.Context, in *ListSkuLocationsRequest, opts ...grpc.CallOption) (*ListSkuLocationsResponse, error)
}

type aiModelServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAiModelServiceClient(cc grpc.ClientConnInterface) AiModelServiceClient {
	return &aiModelServiceClient{cc}
}

func (c *aiModelServiceClient) ListModels(ctx context.Context, in *ListModelsRequest, opts ...grpc.CallOption) (*ListModelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListModelsResponse)
	err := c.cc.Invoke(ctx, AiModelService_ListModels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiModelServiceClient) ListModelVersions(ctx context.Context, in *ListModelVersionsRequest, opts ...grpc.CallOption) (*ListModelVersionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListModelVersionsResponse)
	err := c.cc.Invoke(ctx, AiModelService_ListModelVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiModelServiceClient) ListModelSkus(ctx context.Context, in *ListModelSkusRequest, opts ...grpc.CallOption) (*ListModelSkusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListModelSkusResponse)
	err := c.cc.Invoke(ctx, AiModelService_ListModelSkus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiModelServiceClient) GetModelDeployment(ctx context.Context, in *GetModelDeploymentRequest, opts ...grpc.CallOption) (*GetModelDeploymentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetModelDeploymentResponse)
	err := c.cc.Invoke(ctx, AiModelService_GetModelDeployment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiModelServiceClient) ResolveModelDeployment(ctx context.Context, in *ResolveModelDeploymentRequest, opts ...grpc.CallOption) (*ResolveModelDeploymentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResolveModelDeploymentResponse)
	err := c.cc.Invoke(ctx, AiModelService_ResolveModelDeployment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiModelServiceClient) ValidateModelAvailability(ctx context.Context, in *ValidateModelAvailabilityRequest, opts ...grpc.CallOption) (*ValidateModelAvailabilityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateModelAvailabilityResponse)
	err := c.cc.Invoke(ctx, AiModelService_ValidateModelAvailability_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiModelServiceClient) ListUsages(ctx context.Context, in *ListUsagesRequest, opts ...grpc.CallOption) (*ListUsagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUsagesResponse)
	err := c.cc.Invoke(ctx, AiModelService_ListUsages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiModelServiceClient) ListLocationsWithQuota(ctx context.Context, in *ListLocationsWithQuotaRequest, opts ...grpc.CallOption) (*ListLocationsWithQuotaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLocationsWithQuotaResponse)
	err := c.cc.Invoke(ctx, AiModelService_ListLocationsWithQuota_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiModelServiceClient) ListSkuLocations(ctx context.Context, in *ListSkuLocationsRequest, opts ...grpc.CallOption) (*ListSkuLocationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSkuLocationsResponse)
	err := c.cc.Invoke(ctx, AiModelService_ListSkuLocations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AiModelServiceServer is the server API for AiModelService service.
// All implementations must embed UnimplementedAiModelServiceServer
// for forward compatibility.
type AiModelServiceServer interface {
	// ListModels lists AI models, optionally filtered by location, capabilities, format, kind, status.
	// If no location is specified, aggregates across all available locations concurrently.
	ListModels(context.Context, *ListModelsRequest) (*ListModelsResponse, error)
	// ListModelVersions gets available versions for a specific model in a location.
	ListModelVersions(context.Context, *ListModelVersionsRequest) (*ListModelVersionsResponse, error)
	// ListModelSkus gets available SKUs for a specific model and version in a location.
	ListModelSkus(context.Context, *ListModelSkusRequest) (*ListModelSkusResponse, error)
	// GetModelDeployment gets deployment configuration for a model, resolving defaults for version, SKU, and capacity.
	GetModelDeployment(context.Context, *GetModelDeploymentRequest) (*GetModelDeploymentResponse, error)
	// ResolveModelDeployment resolves a deployment configuration with quota validation.
	// Attempts to find a deployment that satisfies the specified preferences AND has available quota.
	// Falls back through SKU/location alternatives if the preferred configuration lacks quota.
	ResolveModelDeployment(context.Context, *ResolveModelDeploymentRequest) (*ResolveModelDeploymentResponse, error)
	// ValidateModelAvailability checks whether a model can be deployed in a location.
	// Returns availability status and, if unavailable, alternative locations and models.
	ValidateModelAvailability(context.Context, *ValidateModelAvailabilityRequest) (*ValidateModelAvailabilityResponse, error)
	// ListUsages gets quota and usage for AI services in a location (TPM allocation, remaining capacity).
	ListUsages(context.Context, *ListUsagesRequest) (*ListUsagesResponse, error)
	// ListLocationsWithQuota finds locations that have sufficient quota for specified usage requirements.
	ListLocationsWithQuota(context.Context, *ListLocationsWithQuotaRequest) (*ListLocationsWithQuotaResponse, error)
	// ListSkuLocations gets available locations for AI Services resource SKUs.
	ListSkuLocations(context.Context, *ListSkuLocationsRequest) (*ListSkuLocationsResponse, error)
	mustEmbedUnimplementedAiModelServiceServer()
}

// UnimplementedAiModelServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAiModelServiceServer struct{}

func (UnimplementedAiModelServiceServer) ListModels(context.Context, *ListModelsRequest) (*ListModelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListModels not implemented")
}
func (UnimplementedAiModelServiceServer) ListModelVersions(context.Context, *ListModelVersionsRequest) (*ListModelVersionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListModelVersions not implemented")
}
func (UnimplementedAiModelServiceServer) ListModelSkus(context.Context, *ListModelSkusRequest) (*ListModelSkusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListModelSkus not implemented")
}
func (UnimplementedAiModelServiceServer) GetModelDeployment(context.Context, *GetModelDeploymentRequest) (*GetModelDeploymentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModelDeployment not implemented")
}
func (UnimplementedAiModelServiceServer) ResolveModelDeployment(context.Context, *ResolveModelDeploymentRequest) (*ResolveModelDeploymentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveModelDeployment not implemented")
}
func (UnimplementedAiModelServiceServer) ValidateModelAvailability(context.Context, *ValidateModelAvailabilityRequest) (*ValidateModelAvailabilityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateModelAvailability not implemented")
}
func (UnimplementedAiModelServiceServer) ListUsages(context.Context, *ListUsagesRequest) (*ListUsagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUsages not implemented")
}
func (UnimplementedAiModelServiceServer) ListLocationsWithQuota(context.Context, *ListLocationsWithQuotaRequest) (*ListLocationsWithQuotaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLocationsWithQuota not implemented")
}
func (UnimplementedAiModelServiceServer) ListSkuLocations(context.Context, *ListSkuLocationsRequest) (*ListSkuLocationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSkuLocations not implemented")
}
func (UnimplementedAiModelServiceServer) mustEmbedUnimplementedAiModelServiceServer() {}
func (UnimplementedAiModelServiceServer) testEmbeddedByValue()                        {}

// UnsafeAiModelServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AiModelServiceServer will
// result in compilation errors.
type UnsafeAiModelServiceServer interface {
	mustEmbedUnimplementedAiModelServiceServer()
}

func RegisterAiModelServiceServer(s grpc.ServiceRegistrar, srv AiModelServiceServer) {
	// If the following call pancis, it indicates UnimplementedAiModelServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AiModelService_ServiceDesc, srv)
}

func _AiModelService_ListModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiModelServiceServer).ListModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiModelService_ListModels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiModelServiceServer).ListModels(ctx, req.(*ListModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiModelService_ListModelVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListModelVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiModelServiceServer).ListModelVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiModelService_ListModelVersions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiModelServiceServer).ListModelVersions(ctx, req.(*ListModelVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiModelService_ListModelSkus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListModelSkusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiModelServiceServer).ListModelSkus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiModelService_ListModelSkus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiModelServiceServer).ListModelSkus(ctx, req.(*ListModelSkusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiModelService_GetModelDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModelDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiModelServiceServer).GetModelDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiModelService_GetModelDeployment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiModelServiceServer).GetModelDeployment(ctx, req.(*GetModelDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiModelService_ResolveModelDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveModelDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiModelServiceServer).ResolveModelDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiModelService_ResolveModelDeployment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiModelServiceServer).ResolveModelDeployment(ctx, req.(*ResolveModelDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiModelService_ValidateModelAvailability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateModelAvailabilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiModelServiceServer).ValidateModelAvailability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiModelService_ValidateModelAvailability_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiModelServiceServer).ValidateModelAvailability(ctx, req.(*ValidateModelAvailabilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiModelService_ListUsages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUsagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiModelServiceServer).ListUsages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiModelService_ListUsages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiModelServiceServer).ListUsages(ctx, req.(*ListUsagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiModelService_ListLocationsWithQuota_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLocationsWithQuotaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiModelServiceServer).ListLocationsWithQuota(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiModelService_ListLocationsWithQuota_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiModelServiceServer).ListLocationsWithQuota(ctx, req.(*ListLocationsWithQuotaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiModelService_ListSkuLocations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSkuLocationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiModelServiceServer).ListSkuLocations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiModelService_ListSkuLocations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiModelServiceServer).ListSkuLocations(ctx, req.(*ListSkuLocationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AiModelService_ServiceDesc is the grpc.ServiceDesc for AiModelService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AiModelService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "azdext.AiModelService",
	HandlerType: (*AiModelServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListModels",
			Handler:    _AiModelService_ListModels_Handler,
		},
		{
			MethodName: "ListModelVersions",
			Handler:    _AiModelService_ListModelVersions_Handler,
		},
		{
			MethodName: "ListModelSkus",
			Handler:    _AiModelService_ListModelSkus_Handler,
		},
		{
			MethodName: "GetModelDeployment",
			Handler:    _AiModelService_GetModelDeployment_Handler,
		},
		{
			MethodName: "ResolveModelDeployment",
			Handler:    _AiModelService_ResolveModelDeployment_Handler,
		},
		{
			MethodName: "ValidateModelAvailability",
			Handler:    _AiModelService_ValidateModelAvailability_Handler,
		},
		{
			MethodName: "ListUsages",
			Handler:    _AiModelService_ListUsages_Handler,
		},
		{
			MethodName: "ListLocationsWithQuota",
			Handler:    _AiModelService_ListLocationsWithQuota_Handler,
		},
		{
			MethodName: "ListSkuLocations",
			Handler:    _AiModelService_ListSkuLocations_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ai_model.proto",
}
